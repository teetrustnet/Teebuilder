use super::utils::u256decimal_serde_helper;
use alloy_primitives::{utils::parse_ether, Address, BlockHash, U256};
use alloy_rpc_types_beacon::BlsPublicKey;
use flate2::{write::GzEncoder, Compression};
use governor::{DefaultDirectRateLimiter, Quota, RateLimiter};
use rbuilder_primitives::mev_boost::{
    KnownRelay, MevBoostRelayID, RelayMode, SubmitBlockRequestNoBlobs,
    SubmitBlockRequestWithMetadata, SubmitHeaderRequestWithMetadata, ValidatorRegistration,
    ValidatorSlotData, MEV_BOOST_SLOT_INFO_REQUEST_TIMEOUT,
};
use reqwest::{
    header::{HeaderMap, HeaderValue, AUTHORIZATION, CONTENT_ENCODING, CONTENT_TYPE},
    Body, Response, StatusCode,
};
use serde::{Deserialize, Deserializer, Serialize};
use serde_with::{serde_as, DisplayFromStr};
use ssz::Encode;
use std::{io::Write, sync::Arc, time::Duration};
use tracing::*;
use url::Url;

pub mod bloxroute_grpc;
use bloxroute_grpc::GrpcRelayClient;

mod error;
pub mod fake_mev_boost_relay;
pub mod optimistic_v3;
pub mod rpc;
pub mod sign_payload;
pub use error::*;
pub use sign_payload::*;

const TOTAL_PAYMENT_HEADER: &str = "Total-Payment";
const BUNDLE_HASHES_HEADER: &str = "Bundle-Hashes";
const TOP_BID_HEADER: &str = "Top-Bid";
const BLOXROUTE_SHARE_HEADER: &str = "share";
const BLOXROUTE_BUILDER_VALUE_HEADER: &str = "builder-value";
const X_SEQUENCE_HEADER: &str = "x-sequence";

const JSON_CONTENT_TYPE: &str = "application/json";
const SSZ_CONTENT_TYPE: &str = "application/octet-stream";
const GZIP_CONTENT_ENCODING: &str = "gzip";

const BUILDER_ID_HEADER: &str = "X-Builder-Id";
const API_TOKEN_HEADER: &str = "X-Api-Token";

/// We don't have nice error codes for relay errors so we have to parse looking for substrings :(
/// Simulation error base.
const SIM_FAILED_SUBSTRING: &str = "simulation failed";
/// Any error containing SIM_FAILED_SUBSTRING and any of SIM_FAILED_NON_CRITICAL_ERRORS is not critical so we should not stop block building.
const SIM_FAILED_NON_CRITICAL_ERRORS: &[&str] = &[
    "blacklisted address", // Generated block is good but contains a blacklisted address. This happens if we don't use an blacklist but the relay does.
    "unknown ancestor",
    "missing trie node",
    "parent block not found", // Generated from time to time from agnostic relay "simulation failed: parent block not found"
    "block is too old, outside validation window", // Generated from time to time from agnostic relay in the end of the slot
    "block gas limit mismatch", // Generated from time to time from ultrasounds relay when we ignore the gas limit.
    "Proposer MEV Protect is enabled", // Generated by bloxroute since we didn't implement Proposer MEV Protect. On 2025/07/17 this is still not critical (the block is still valid) and it's not clear if it will ever be reason for demotion.
    "no state found for block",        // Generated by reth validation nodes that are out of sync
];

/// If the bid we send is below a non cancellable bid from the competition agnostics answers this.
const AGNOSTIC_RELAY_ACCEPTED_BID_BELOW_FLOOR_TXT: &str =
    "accepted bid below floor, skipped validation";
const AGNOSTIC_RELAY_ACCEPTED_BID_BELOW_FLOOR_CODE: StatusCode = StatusCode::ACCEPTED;

fn is_ignorable_relay_error(code: StatusCode, text: &str) -> bool {
    code == AGNOSTIC_RELAY_ACCEPTED_BID_BELOW_FLOOR_CODE
        && text.contains(AGNOSTIC_RELAY_ACCEPTED_BID_BELOW_FLOOR_TXT)
}

#[derive(Debug, Clone, Deserialize, PartialEq, Eq, Default)]
#[serde(deny_unknown_fields)]
pub struct RelayConfig {
    pub name: MevBoostRelayID,
    pub url: String,
    #[serde(default)]
    pub grpc_url: Option<String>,
    #[serde(default, deserialize_with = "deserialize_env_var")]
    pub authorization_header: Option<String>,
    #[serde(default, deserialize_with = "deserialize_env_var")]
    pub builder_id_header: Option<String>,
    #[serde(default, deserialize_with = "deserialize_env_var")]
    pub api_token_header: Option<String>,
    /// mode defines the need of submit_config
    #[serde(default)]
    pub mode: RelayMode,
    /// Bid adjustment fee payer address.
    pub adjustment_fee_payer: Option<Address>,
    #[serde(flatten)]
    /// Submit specific info.
    /// Used only for Full and Fake mode.
    pub submit_config: Option<RelaySubmitConfig>,
    /// Deprecated field that is not used
    pub priority: Option<usize>,
    /// Set to `true` for bloxroute relays.
    #[serde(default)]
    pub is_bloxroute: bool,
    /// The list of bloxroute rproxy regions to send to order by preference.
    #[serde(default)]
    pub bloxroute_rproxy_regions: Vec<String>,
    /// Flag indicating whether the builder should only submit to rproxy endpoinds if available.
    #[serde(default)]
    pub bloxroute_rproxy_only: bool,
    /// Adds "filtering=true" as query to the call relay/v1/builder/validators to get all validators (including those filtering OFAC)
    /// On 2025/06/24 (my birthday!) only supported by ultrasound.
    /// None -> false
    pub ask_for_filtering_validators: Option<bool>,
    /// If we submit a block with a different gas than the one the validator registered with in this relay the relay does not mind.
    /// None -> false
    pub can_ignore_gas_limit: Option<bool>,
}

#[derive(Debug, Clone, Deserialize, PartialEq, Eq, Default)]
#[serde(deny_unknown_fields)]
pub struct RelaySubmitConfig {
    /// true->ssz false->json
    #[serde(default)]
    pub use_ssz_for_submit: bool,
    #[serde(default)]
    pub use_gzip_for_submit: bool,
    #[serde(default)]
    pub optimistic: bool,
    /// Flag indicating whether optimistic V3 submissions should be used.
    #[serde(default)]
    pub optimistic_v3: bool,
    /// Flag indicating whether bid adjustments are required for optimistic v3 submissions.
    #[serde(default)]
    pub optimistic_v3_bid_adjustment_required: bool,
    #[serde(default)]
    pub interval_between_submissions_ms: Option<u64>,
    /// Max bid we can submit to this relay. Any bid above this will be skipped.
    /// None -> No limit.
    pub max_bid_eth: Option<String>,
}

impl RelayConfig {
    pub fn with_url(self, url: &str) -> Self {
        Self {
            url: url.to_string(),
            ..self
        }
    }

    pub fn with_name(self, name: &str) -> Self {
        Self {
            name: name.to_string(),
            ..self
        }
    }
}

/// Client to access part of relay APIs. See:
/// https://ethereum.github.io/builder-specs/#/Builder
/// https://flashbots.github.io/relay-specs/
#[derive(Debug, Clone)]
pub struct RelayClient {
    client: reqwest::Client,
    /// Bloxroute gRPC client. If set, it will be used for block submissions.
    grpc_client: Option<GrpcRelayClient>,
    url: Url,
    authorization_header: Option<String>,
    builder_id_header: Option<String>,
    api_token_header: Option<String>,
    /// Flag indicating whether this is the bloxroute relay.
    is_bloxroute: bool,
    /// Bloxroute rproxy regions.
    bloxroute_rproxy_regions: Vec<String>,
    /// Flag indicating whether rproxy regions are required.
    bloxroute_rproxy_only: bool,
    /// Adds "filtering=true" as query
    ask_for_filtering_validators: bool,
    /// If we submit a block with a different gas than the one the validator registered with in this relay the relay does not mind.
    can_ignore_gas_limit: bool,
}

impl RelayClient {
    #[allow(clippy::too_many_arguments)]
    pub fn from_url(
        url: Url,
        authorization_header: Option<String>,
        builder_id_header: Option<String>,
        api_token_header: Option<String>,
        is_bloxroute: bool,
        bloxroute_rproxy_regions: Vec<String>,
        bloxroute_rproxy_only: bool,
        ask_for_filtering_validators: bool,
        can_ignore_gas_limit: bool,
    ) -> Self {
        Self {
            client: reqwest::Client::new(),
            grpc_client: None,
            url,
            authorization_header,
            builder_id_header,
            api_token_header,
            is_bloxroute,
            bloxroute_rproxy_regions,
            bloxroute_rproxy_only,
            ask_for_filtering_validators,
            can_ignore_gas_limit,
        }
    }

    pub fn from_known_relay(relay: KnownRelay) -> Self {
        Self::from_url(
            relay.url(),
            None,
            None,
            None,
            relay.is_bloxroute(),
            Vec::new(),
            false,
            false,
            false,
        )
    }

    pub fn with_grpc_client(mut self, grpc_client: GrpcRelayClient) -> Self {
        self.grpc_client = Some(grpc_client);
        self
    }

    pub fn can_ignore_gas_limit(&self) -> bool {
        self.can_ignore_gas_limit
    }

    pub fn with_reqwest_client(mut self, client: reqwest::Client) -> Self {
        self.client = client;
        self
    }
}

/// Wrapper in RelayClient to submit blocks.
/// Hides the particular configuration (eg: ssz, gip, optimistic).
/// cancellation hardcoded on true for now.
#[derive(Debug, Clone)]
pub struct MevBoostRelayBidSubmitter {
    /// Id for UI
    id: MevBoostRelayID,

    client: RelayClient,
    /// true -> ssz; false -> json.
    use_ssz_for_submit: bool,
    use_gzip_for_submit: bool,
    /// Relay accepts optimistic submissions.
    optimistic: bool,
    submission_rate_limiter: Option<Arc<DefaultDirectRateLimiter>>,
    /// Parameter for the relay
    cancellations: bool,
    /// Flag indicating whether optimistic v3 submissions should be used.
    optimistic_v3: bool,
    /// Flag indicating whether bid adjustments are required for optimistic v3 submissions.
    optimistic_v3_bid_adjustment_required: bool,
    /// Max bid we can submit to this relay. Any bid above this will be skipped.
    /// None -> No limit.
    max_bid: Option<U256>,
    /// This is not a real relay so we can send blocks to it even if it does not have any validator registered.
    test_relay: bool,
}

impl MevBoostRelayBidSubmitter {
    pub fn new(
        client: RelayClient,
        id: MevBoostRelayID,
        config: &RelaySubmitConfig,
        test_relay: bool,
    ) -> eyre::Result<Self> {
        let max_bid = config
            .max_bid_eth
            .as_ref()
            .map(|s| parse_ether(s))
            .transpose()
            .map_err(|e| eyre::eyre!("Failed to parse max bid: {}", e))?;
        let submission_rate_limiter = config.interval_between_submissions_ms.map(|d| {
            Arc::new(RateLimiter::direct(
                Quota::with_period(Duration::from_millis(d)).expect("Rate limiter time period"),
            ))
        });
        Ok(Self {
            id,
            client,
            use_ssz_for_submit: config.use_ssz_for_submit,
            use_gzip_for_submit: config.use_gzip_for_submit,
            optimistic: config.optimistic,
            submission_rate_limiter,
            cancellations: true,
            optimistic_v3: config.optimistic_v3,
            optimistic_v3_bid_adjustment_required: config.optimistic_v3_bid_adjustment_required,
            max_bid,
            test_relay,
        })
    }

    pub fn id(&self) -> &MevBoostRelayID {
        &self.id
    }

    pub fn test_relay(&self) -> bool {
        self.test_relay
    }

    pub fn optimistic(&self) -> bool {
        self.optimistic
    }

    pub fn optimistic_v3(&self) -> bool {
        self.optimistic_v3
    }

    pub fn optimistic_v3_bid_adjustment_required(&self) -> bool {
        self.optimistic_v3_bid_adjustment_required
    }

    pub fn max_bid(&self) -> Option<U256> {
        self.max_bid
    }

    /// false -> rate limiter don't allow
    pub fn can_submit_bid(&self) -> bool {
        if let Some(limiter) = &self.submission_rate_limiter {
            limiter.check().is_ok()
        } else {
            true
        }
    }

    pub async fn submit_block(
        &self,
        data: SubmitBlockRequestWithMetadata,
        registration: ValidatorSlotData,
    ) -> Result<(), SubmitBlockErr> {
        self.client
            .submit_block(
                &data,
                &registration,
                self.use_ssz_for_submit,
                self.use_gzip_for_submit,
                self.test_relay,
                self.cancellations,
            )
            .await
    }

    pub async fn submit_optimistic_v3(
        &self,
        data: SubmitHeaderRequestWithMetadata,
        registration: ValidatorSlotData,
    ) -> Result<(), SubmitBlockErr> {
        self.client
            .submit_optimistic_v3(&data, &registration, self.cancellations)
            .await
    }
}

/// Wrapper over RelayClient that allows to ask for slot validators info.
#[derive(Debug, Clone)]
pub struct MevBoostRelaySlotInfoProvider {
    /// Id for UI
    id: MevBoostRelayID,
    client: RelayClient,
}

impl MevBoostRelaySlotInfoProvider {
    pub fn new(client: RelayClient, id: String) -> Self {
        // we use separate request client for requesting validator data from the relay
        // 1. it separates TCP connections that are used for submissions and other requests to the relay
        // 2. it adds request timeout to epoch data request and its not needed for submissions
        let req_client = reqwest::ClientBuilder::new()
            .timeout(MEV_BOOST_SLOT_INFO_REQUEST_TIMEOUT)
            .build()
            .expect("failed to create reqwest client");
        let client = client.with_reqwest_client(req_client);

        Self { client, id }
    }
    pub fn id(&self) -> &MevBoostRelayID {
        &self.id
    }

    /// A little ugly, needed for backtest payload fetcher.
    pub fn client(&self) -> RelayClient {
        self.client.clone()
    }

    pub async fn get_current_epoch_validators(&self) -> Result<Vec<ValidatorSlotData>, RelayError> {
        self.client.get_current_epoch_validators().await
    }

    pub fn can_ignore_gas_limit(&self) -> bool {
        self.client.can_ignore_gas_limit()
    }
}

#[serde_as]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct ProposerPayloadDelivered {
    #[serde_as(as = "DisplayFromStr")]
    pub slot: u64,
    pub parent_hash: BlockHash,
    pub block_hash: BlockHash,
    pub builder_pubkey: BlsPublicKey,
    pub proposer_pubkey: BlsPublicKey,
    pub proposer_fee_recipient: Address,
    #[serde_as(as = "DisplayFromStr")]
    pub gas_limit: u64,
    #[serde_as(as = "DisplayFromStr")]
    pub gas_used: u64,
    #[serde(with = "u256decimal_serde_helper")]
    pub value: U256,
    #[serde_as(as = "DisplayFromStr")]
    pub block_number: u64,
    #[serde_as(as = "DisplayFromStr")]
    pub num_tx: u64,
}

#[serde_as]
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct BuilderBlockReceived {
    #[serde_as(as = "DisplayFromStr")]
    pub slot: u64,
    pub parent_hash: BlockHash,
    pub block_hash: BlockHash,
    pub builder_pubkey: BlsPublicKey,
    pub proposer_pubkey: BlsPublicKey,
    pub proposer_fee_recipient: Address,
    #[serde_as(as = "DisplayFromStr")]
    pub gas_limit: u64,
    #[serde_as(as = "DisplayFromStr")]
    pub gas_used: u64,
    #[serde(with = "u256decimal_serde_helper")]
    pub value: U256,
    #[serde_as(as = "DisplayFromStr")]
    pub num_tx: u64,
    #[serde_as(as = "DisplayFromStr")]
    pub block_number: u64,
    #[serde_as(as = "DisplayFromStr")]
    pub timestamp: u64,
    #[serde_as(as = "DisplayFromStr")]
    pub timestamp_ms: u64,
    #[serde(default)]
    pub optimistic_submission: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RelayResponse<T> {
    Ok(T),
    Error(RedactableRelayErrorResponse),
}

/// Relay validator registration with auxilary data.
#[derive(PartialEq, Debug, Clone)]
pub struct RelaySlotData {
    /// Validator slot registration.
    pub registration: ValidatorSlotData,
    /// Fee payer address for bid adjustments.
    pub adjustment_fee_payer: Option<Address>,
}

/// Bloxroute validator RProxy details.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize, Hash)]
pub struct BloxrouteRegionalEndpoint {
    /// RProxy name
    pub name: String,
    /// RProxy region. Format: `city,region`.
    pub region: String,
    /// RProxy HTTP endpoint.
    pub http_endpoint: String,
    /// RProxy gRPC endpoint.
    pub grpc_endpoint: String,
    /// RProxy WS endpoint.
    pub websocket_endpoint: String,
}

#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("Too many txs")]
    TooManyTxs,
    #[error("Tx to big")]
    TxTooBig,
    #[error("Extra data too big")]
    ExtraDataTooBig,
    #[error("Too many withdrawals")]
    TooManyWithdrawals,
    #[error("Invalid signature")]
    InvalidSignature,
    #[error("Wrong KzgCommitment size")]
    WrongKzgCommitmentSize,
    #[error("Too many KzgCommitment")]
    TooManyKzgCommitments,
    #[error("Too many blobs")]
    TooManyBlobs,
    #[error("Blob to big")]
    BlobTooBig,
    #[error("Wrong proof size")]
    WrongProofSize,
    #[error("Too many proofs")]
    TooManyProofs,
}

#[derive(thiserror::Error)]
pub enum SubmitBlockErr {
    #[error("Relay error: {0}")]
    RelayError(#[from] RelayError),
    #[error("Invalid URL: {0}")]
    InvalidUrl(#[from] url::ParseError),
    #[error("Payload attributes are not known")]
    PayloadAttributesNotKnown,
    #[error("Past slot")]
    PastSlot,
    #[error("Payload delivered")]
    PayloadDelivered,
    #[error("Bid below floor")]
    BidBelowFloor,
    #[cfg_attr(not(feature = "redact-sensitive"), error("Simulation Error: {0}"))]
    #[cfg_attr(feature = "redact-sensitive", error("Simulation Error: [REDACTED]"))]
    SimError(String),
    #[error("RPC conversion Error")]
    /// RPC validates the submissions (eg: limit of txs) much more that our model.
    RPCConversionError(Error),
    #[cfg_attr(
        not(feature = "redact-sensitive"),
        error("RPC serialization failed: {0}")
    )]
    #[cfg_attr(
        feature = "redact-sensitive",
        error("RPC serialization failed: [REDACTED]")
    )]
    RPCSerializationError(String),
    #[error("Invalid header")]
    InvalidHeader,
    #[error("Block known")]
    BlockKnown,
    #[error("No rproxy available")]
    NoRproxyAvailable,
    #[error("gRPC error")]
    Grpc(#[from] Box<tonic::Status>),
}

impl std::fmt::Debug for SubmitBlockErr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{self}")
    }
}

// Data API
impl RelayClient {
    async fn get_one_delivered_payload(
        &self,
        query: &str,
    ) -> Result<Option<ProposerPayloadDelivered>, RelayError> {
        let url = {
            let mut url = self.url.clone();
            url.set_path("/relay/v1/data/bidtraces/proposer_payload_delivered");
            url.set_query(Some(query));
            url
        };

        let payloads = reqwest::get(url)
            .await?
            .json::<RelayResponse<Vec<ProposerPayloadDelivered>>>()
            .await?;

        match payloads {
            RelayResponse::Ok(payloads) => {
                if payloads.is_empty() {
                    return Ok(None);
                }
                Ok(Some(payloads[0].clone()))
            }
            RelayResponse::Error(error) => Err(RelayError::RelayError(error)),
        }
    }

    pub async fn proposer_payload_delivered_slot(
        &self,
        slot: u64,
    ) -> Result<Option<ProposerPayloadDelivered>, RelayError> {
        self.get_one_delivered_payload(&format!("slot={slot}"))
            .await
    }

    pub async fn proposer_payload_delivered_block_number(
        &self,
        block_number: u64,
    ) -> Result<Option<ProposerPayloadDelivered>, RelayError> {
        self.get_one_delivered_payload(&format!("block_number={block_number}"))
            .await
    }

    pub async fn proposer_payload_delivered_block_hash(
        &self,
        block_hash: BlockHash,
    ) -> Result<Option<ProposerPayloadDelivered>, RelayError> {
        self.get_one_delivered_payload(&format!("block_hash={block_hash:?}"))
            .await
    }

    async fn get_one_builder_block_received(
        &self,
        query: &str,
    ) -> Result<Option<BuilderBlockReceived>, RelayError> {
        let url = {
            let mut url = self.url.clone();
            url.set_path("/relay/v1/data/bidtraces/builder_blocks_received");
            url.set_query(Some(query));
            url
        };

        let payloads = reqwest::get(url)
            .await?
            .json::<RelayResponse<Vec<BuilderBlockReceived>>>()
            .await?;

        match payloads {
            RelayResponse::Ok(payloads) => {
                if payloads.is_empty() {
                    return Ok(None);
                }
                Ok(Some(payloads[0].clone()))
            }
            RelayResponse::Error(error) => Err(RelayError::RelayError(error)),
        }
    }

    pub async fn builder_block_received_block_hash(
        &self,
        block_hash: BlockHash,
    ) -> Result<Option<BuilderBlockReceived>, RelayError> {
        self.get_one_builder_block_received(&format!("block_hash={block_hash:?}"))
            .await
    }

    pub async fn validator_registration(
        &self,
        pubkey: BlsPublicKey,
    ) -> Result<Option<ValidatorRegistration>, RelayError> {
        let url = {
            let mut url = self.url.clone();
            url.set_path("/relay/v1/data/validator_registration");
            url.set_query(Some(&format!("pubkey={pubkey:?}")));
            url
        };

        let registration = reqwest::get(url)
            .await?
            .json::<RelayResponse<ValidatorRegistration>>()
            .await?;

        match registration {
            RelayResponse::Ok(registration) => Ok(Some(registration)),
            RelayResponse::Error(error) => {
                if error.code == Some(400) {
                    return Ok(None);
                }
                Err(RelayError::RelayError(error))
            }
        }
    }

    /// Calls /relay/v1/builder/validators to get "validator registrations for validators scheduled to propose in the current and next epoch."
    /// The result will contain the validators for each slot.
    pub async fn get_current_epoch_validators(&self) -> Result<Vec<ValidatorSlotData>, RelayError> {
        let url = {
            let mut url = self.url.clone();
            url.set_path("/relay/v1/builder/validators");
            if self.ask_for_filtering_validators {
                url.set_query(Some("filtering=true"));
            }
            url
        };
        let req = self.client.get(url);
        let mut headers = HeaderMap::new();
        self.add_auth_headers(&mut headers)
            .map_err(|_| RelayError::InvalidHeader)?;
        let validators = req
            .headers(headers)
            .send()
            .await?
            .json::<RelayResponse<Vec<ValidatorSlotData>>>()
            .await?;

        match validators {
            RelayResponse::Ok(validators) => Ok(validators),
            RelayResponse::Error(error) => Err(RelayError::RelayError(error)),
        }
    }

    /// Mainly takes care of ssz/json raw/gzip
    async fn call_relay_submit_block(
        &self,
        submission_with_metadata: &SubmitBlockRequestWithMetadata,
        registration: &ValidatorSlotData,
        ssz: bool,
        gzip: bool,
        fake_relay: bool,
        cancellations: bool,
    ) -> Result<Response, SubmitBlockErr> {
        let SubmitBlockRequestWithMetadata {
            submission,
            metadata,
        } = submission_with_metadata;

        let mut headers = HeaderMap::new();
        headers.insert(X_SEQUENCE_HEADER, metadata.sequence.into());
        self.add_auth_headers(&mut headers)
            .map_err(|_| SubmitBlockErr::InvalidHeader)?;

        let mut url = self.get_base_submit_block_url(registration, &mut headers)?;
        url.set_path("/relay/v1/builder/blocks");
        url.query_pairs_mut()
            .append_pair("cancellations", if cancellations { "1" } else { "0" });
        if submission.has_adjustment_data() {
            url.query_pairs_mut().append_pair("adjustments", "1");
        }

        let mut builder = self.client.post(url.clone());
        // SSZ vs JSON
        let (mut body_data, content_type) = if ssz {
            (submission.as_ssz_bytes(), SSZ_CONTENT_TYPE)
        } else {
            let json_result = if fake_relay {
                // For the fake relay we remove the blobs
                serde_json::to_vec(&SubmitBlockRequestNoBlobs(submission))
            } else {
                serde_json::to_vec(submission)
            };

            (
                json_result.map_err(|e| SubmitBlockErr::RPCSerializationError(e.to_string()))?,
                JSON_CONTENT_TYPE,
            )
        };
        headers.insert(CONTENT_TYPE, HeaderValue::from_static(content_type));

        // GZIP
        if gzip {
            headers.insert(
                CONTENT_ENCODING,
                HeaderValue::from_static(GZIP_CONTENT_ENCODING),
            );
            let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
            encoder
                .write_all(&body_data)
                .map_err(|e| SubmitBlockErr::RPCSerializationError(e.to_string()))?;
            body_data = encoder
                .finish()
                .map_err(|e| SubmitBlockErr::RPCSerializationError(e.to_string()))?;
        }

        // Set bloxroute specific headers.
        if self.is_bloxroute {
            headers.insert(
                BLOXROUTE_BUILDER_VALUE_HEADER,
                metadata
                    .value
                    .coinbase_reward
                    .to_string()
                    .parse()
                    .map_err(|_| RelayError::InvalidHeader)?,
            );
        }

        builder = builder.headers(headers).body(Body::from(body_data));
        if fake_relay {
            builder = builder.header(
                TOTAL_PAYMENT_HEADER,
                metadata.value.coinbase_reward.to_string(),
            );
            if let Some(top_competitor_bid) = metadata.value.top_competitor_bid {
                builder = builder.header(TOP_BID_HEADER, top_competitor_bid.to_string());
            }

            const MAX_BUNDLE_HASHES: usize = 150;
            if !metadata.bundle_hashes.is_empty() {
                let bundle_hashes: Vec<_> = metadata
                    .bundle_hashes
                    .iter()
                    .take(MAX_BUNDLE_HASHES)
                    .map(|h| format!("{h:?}"))
                    .collect();

                let bundle_hashes = if bundle_hashes.len() > MAX_BUNDLE_HASHES {
                    bundle_hashes.join(",") + ",CAPPED"
                } else {
                    bundle_hashes.join(",")
                };
                builder = builder.header(BUNDLE_HASHES_HEADER, bundle_hashes);
            }

            let sent_at = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs_f64();
            builder = builder.header("X-BuilderNet-SentAt", sent_at.to_string());
        }

        let response = builder
            .send()
            .await
            .map_err(|e| RelayError::RequestError(e.into()))?;
        Ok(response)
    }

    /// Send gRPC submit block request to bloxroute.
    async fn call_bloxroute_grpc_submit_block(
        &self,
        client: &GrpcRelayClient,
        submission: &SubmitBlockRequestWithMetadata,
    ) -> Result<bloxroute_grpc::types::SubmitBlockResponse, SubmitBlockErr> {
        let mut request = tonic::Request::new(bloxroute_grpc::types::SubmitBlockRequest::from(
            &submission.submission,
        ));
        request.set_timeout(Duration::from_secs(2));
        request.metadata_mut().insert(
            "authorization",
            self.authorization_header
                .clone()
                .unwrap_or_default()
                .parse()
                .map_err(|_| SubmitBlockErr::InvalidHeader)?,
        );
        request.metadata_mut().insert(
            BLOXROUTE_BUILDER_VALUE_HEADER,
            submission
                .metadata
                .value
                .coinbase_reward
                .to_string()
                .parse()
                .map_err(|_| SubmitBlockErr::InvalidHeader)?,
        );
        request.metadata_mut().insert(
            BLOXROUTE_SHARE_HEADER,
            "na".parse().map_err(|_| SubmitBlockErr::InvalidHeader)?,
        );

        let sent_at = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_secs_f64();
        request.metadata_mut().insert(
            "x-buildernet-sentat",
            sent_at
                .to_string()
                .parse()
                .map_err(|_| SubmitBlockErr::InvalidHeader)?,
        );

        let response = client
            .lock()
            .await
            .submit_block(request)
            .await
            .map_err(Box::new)?;
        Ok(response.into_inner())
    }

    /// Submits the block (call_relay_submit_block) and processes some special errors.
    pub async fn submit_block(
        &self,
        data: &SubmitBlockRequestWithMetadata,
        registration: &ValidatorSlotData,
        ssz: bool,
        gzip: bool,
        fake_relay: bool,
        cancellations: bool,
    ) -> Result<(), SubmitBlockErr> {
        // If gRPC client is available, attempt to submit with it.
        // TODO: support submitting to rproxy gRPC
        if let Some(client) = &self.grpc_client {
            match self.call_bloxroute_grpc_submit_block(client, data).await {
                Ok(response) => {
                    let status = response.code.try_into().unwrap_or(u16::MAX);
                    return if status == tonic::Code::Ok as u16 {
                        Ok(())
                    } else {
                        Err(map_relay_error_message(&response.message, None))
                    };
                }
                Err(SubmitBlockErr::Grpc(error)) => {
                    if matches!(error.code(), tonic::Code::Unknown) {
                        // Request succeeded, but relay returned an error.
                        return Err(map_relay_error_message(error.message(), None));
                    }

                    // We encountered connection error, possibly due to broken gRPC connection. Proceed to re-submit the block through HTTP.
                    tracing::error!(?error, "Error submitting to gRPC");
                }
                Err(error) => return Err(error),
            };
        }

        let response = self
            .call_relay_submit_block(data, registration, ssz, gzip, fake_relay, cancellations)
            .await?;

        map_response(response).await
    }

    pub async fn submit_optimistic_v3(
        &self,
        request: &SubmitHeaderRequestWithMetadata,
        registration: &ValidatorSlotData,
        cancellations: bool,
    ) -> Result<(), SubmitBlockErr> {
        let SubmitHeaderRequestWithMetadata {
            submission,
            metadata,
        } = request;

        let mut headers = HeaderMap::new();
        headers.insert(X_SEQUENCE_HEADER, metadata.sequence.into());
        self.add_auth_headers(&mut headers)
            .map_err(|_| SubmitBlockErr::InvalidHeader)?;

        let mut url = self.get_base_submit_block_url(registration, &mut headers)?;
        url.set_path("/relay/v3/builder/headers");
        url.query_pairs_mut()
            .append_pair("cancellations", if cancellations { "1" } else { "0" });

        let body = submission.as_ssz_bytes();
        headers.insert(CONTENT_TYPE, HeaderValue::from_static(SSZ_CONTENT_TYPE));

        let response = self
            .client
            .post(url.clone())
            .headers(headers)
            .body(body)
            .send()
            .await
            .map_err(|e| RelayError::RequestError(e.into()))?;

        map_response(response).await
    }

    /// Constructs the URL for block submission.
    /// For the bloxroute relay, if there is no rproxy endpoint to submit to,
    /// sets the sharing header restricting bids to the location of the main relay.
    fn get_base_submit_block_url(
        &self,
        registration: &ValidatorSlotData,
        headers: &mut HeaderMap,
    ) -> Result<Url, SubmitBlockErr> {
        let maybe_regional_endpoint = self.bloxroute_rproxy_regions.iter().find_map(|region| {
            registration
                .regional_endpoints
                .iter()
                .find(|r| r.region.ends_with(region.as_str()))
        });

        if let Some(regional) = maybe_regional_endpoint {
            return Url::parse(&regional.http_endpoint).map_err(|error| {
                error!(?error, url = %regional.http_endpoint, "Error parsing rproxy URL");
                SubmitBlockErr::InvalidUrl(error)
            });
        } else if self.bloxroute_rproxy_only {
            return Err(SubmitBlockErr::NoRproxyAvailable);
        }

        if self.is_bloxroute {
            // It's a bloxroute endpoint and we are not using rProxy, restrict to main relay region.
            headers.insert(BLOXROUTE_SHARE_HEADER, HeaderValue::from_static("na"));
        }
        Ok(self.url.clone())
    }

    fn add_auth_headers(&self, headers: &mut HeaderMap) -> eyre::Result<()> {
        if let Some(authorization_header) = &self.authorization_header {
            let mut value = HeaderValue::from_str(authorization_header)?;
            value.set_sensitive(true);
            headers.insert(AUTHORIZATION, value);
        }
        if let Some(builder_id_header) = &self.builder_id_header {
            let mut value = HeaderValue::from_str(builder_id_header)?;
            value.set_sensitive(true);
            headers.insert(BUILDER_ID_HEADER, value);
        }
        if let Some(api_token_header) = &self.api_token_header {
            let mut value = HeaderValue::from_str(api_token_header)?;
            value.set_sensitive(true);
            headers.insert(API_TOKEN_HEADER, value);
        }
        Ok(())
    }
}

async fn map_response(response: Response) -> Result<(), SubmitBlockErr> {
    let status = response.status();
    if status == StatusCode::TOO_MANY_REQUESTS {
        return Err(RelayError::TooManyRequests.into());
    }
    if status == StatusCode::GATEWAY_TIMEOUT {
        return Err(RelayError::ConnectionError.into());
    }

    let bytes = response
        .bytes()
        .await
        .map_err(|err| RelayError::RequestError(err.into()))?;

    if status == StatusCode::OK && bytes.is_empty() {
        return Ok(());
    }

    match serde_json::from_slice::<RelayResponse<()>>(&bytes) {
        Ok(RelayResponse::Ok(_)) => Ok(()),
        Ok(RelayResponse::Error(error)) => Err(map_relay_error_message(&error.message, error.code)),
        Err(_) => {
            // bloxroute returns empty response in this format which we handle here because its not valid
            // jsonrpc response
            let data = String::from_utf8_lossy(&bytes).to_string();
            if data.trim() == "{}" {
                return Ok(());
            }

            if is_ignorable_relay_error(status, &data) {
                Ok(())
            } else {
                Err(RelayError::UnknownRelayError(status, data).into())
            }
        }
    }
}

fn map_relay_error_message(msg: &str, code: Option<u64>) -> SubmitBlockErr {
    match msg {
        "payload attributes not (yet) known" => SubmitBlockErr::PayloadAttributesNotKnown,
        "submission for past slot" | "submitted block is for past slot" => SubmitBlockErr::PastSlot,
        "accepted bid below floor, skipped validation" => SubmitBlockErr::BidBelowFloor,
        "payload for this slot was already delivered" => SubmitBlockErr::PayloadDelivered,
        "block already received" => SubmitBlockErr::BlockKnown,
        _ if msg.contains("read tcp") => RelayError::ConnectionError.into(),
        _ if msg.contains(SIM_FAILED_SUBSTRING) => {
            if SIM_FAILED_NON_CRITICAL_ERRORS
                .iter()
                .any(|pat| msg.contains(*pat))
            {
                RelayError::InternalError.into()
            } else {
                SubmitBlockErr::SimError(msg.to_string())
            }
        }
        _ if msg.contains("request timeout hit") => RelayError::ConnectionError.into(),
        _ => RelayError::RelayError(RedactableRelayErrorResponse {
            code,
            message: msg.to_owned(),
        })
        .into(),
    }
}

fn deserialize_env_var<'de, D>(deserializer: D) -> Result<Option<String>, D::Error>
where
    D: Deserializer<'de>,
{
    let s: Option<String> = Option::deserialize(deserializer)?;
    Ok(match s {
        Some(val) if val.starts_with("env:") => {
            let env_var = &val[4..];
            std::env::var(env_var).ok()
        }
        _ => s,
    })
}

#[cfg(test)]
mod tests {

    use alloy_primitives::Bytes;
    use alloy_rpc_types_beacon::BlsPublicKey;
    use rbuilder_primitives::mev_boost::{
        BidMetadata, BidValueMetadata, SubmitBlockRequest, ValidatorRegistration,
        ValidatorRegistrationMessage,
    };

    use super::{rpc::TestDataGenerator, *};
    use crate::mev_boost::fake_mev_boost_relay::FakeMevBoostRelay;

    use std::str::FromStr;

    fn create_relay_provider() -> RelayClient {
        RelayClient::from_known_relay(KnownRelay::Flashbots)
    }

    #[test]
    fn test_deserialize_relay_config() {
        let example = "
        name = 'relay1'
        url = 'url'
        authorization_header = 'env:XXX'
        builder_id_header = 'env:YYY'
        api_token_header = 'env:ZZZ'
        mode = 'slot_info'
        ";

        std::env::set_var("XXX", "AAA");
        std::env::set_var("YYY", "BBB");
        std::env::set_var("ZZZ", "CCC");

        let config: RelayConfig = toml::from_str(example).unwrap();
        assert_eq!(config.name, "relay1");
        assert_eq!(config.url, "url");
        assert_eq!(config.priority, None);
        assert_eq!(config.authorization_header.unwrap(), "AAA");
        assert_eq!(config.builder_id_header.unwrap(), "BBB");
        assert_eq!(config.api_token_header.unwrap(), "CCC");
        assert_eq!(config.mode, RelayMode::GetSlotInfoOnly);
    }

    #[test]
    fn test_deserialize_relay_config_modes() {
        let example_base = "
        name = 'relay1'
        url = 'url'
        mode = "
            .to_string();

        let config: RelayConfig = toml::from_str(&(example_base.clone() + "'full'")).unwrap();
        assert_eq!(config.mode, RelayMode::Full);

        let config: RelayConfig = toml::from_str(&(example_base.clone() + "'slot_info'")).unwrap();
        assert_eq!(config.mode, RelayMode::GetSlotInfoOnly);

        let config: RelayConfig = toml::from_str(&(example_base.clone() + "'test'")).unwrap();
        assert_eq!(config.mode, RelayMode::Test);
    }

    #[test]
    fn test_deserialize_relay_config_no_mode() {
        let config = "
        name = 'relay1'
        url = 'url'";

        let config: RelayConfig = toml::from_str(config).unwrap();
        assert_eq!(config.mode, RelayMode::Full);
    }

    #[tokio::test]
    async fn test_proposer_payload_delivered() {
        let relay = create_relay_provider();

        let result_slot = relay
            .proposer_payload_delivered_slot(7251671)
            .await
            .expect("Failed to get proposer payload delivered, slot");
        let result_block_number = relay
            .proposer_payload_delivered_block_number(18064240)
            .await
            .expect("Failed to get proposer payload delivered, block number");
        let result_block_hash = relay
            .proposer_payload_delivered_block_hash(
                BlockHash::from_str(
                    "0xf2ae3ad64c285ab1de2195f23c19b2b2dcf4949b6f71a4a3406bac9734e1ff27",
                )
                .unwrap(),
            )
            .await
            .expect("Failed to get proposer payload delivered, block hash");

        assert_eq!(result_slot, result_block_number);
        assert_eq!(result_block_number, result_block_hash);

        let result = result_slot.expect("Failed to get proposer payload delivered");

        let expected_result = ProposerPayloadDelivered {
            slot: 7251671,
            parent_hash: BlockHash::from_str("0xe57c063ad96fb5b6fe7696dc8509f3a986ace89d06a19951f3e4404f877bb0ca").unwrap(),
            block_hash: BlockHash::from_str("0xf2ae3ad64c285ab1de2195f23c19b2b2dcf4949b6f71a4a3406bac9734e1ff27").unwrap(),
            builder_pubkey: BlsPublicKey::from_str("0x945fc51bf63613257792926c9155d7ae32db73155dc13bdfe61cd476f1fd2297b66601e8721b723cef11e4e6682e9d87").unwrap(),
            proposer_pubkey: BlsPublicKey::from_str("0xb097a69fa420d01c293fed6b2596778d0722a2b076e401c2789cabce773a17c865285ff71b5dd545c7e77bee6ef8a41b").unwrap(),
            proposer_fee_recipient: Address::from_str("0xeBec795c9c8bBD61FFc14A6662944748F299cAcf").unwrap(),
            gas_limit: 30000000,
            gas_used: 20152932,
            value: U256::from_str("488045688257417849").unwrap(),
            num_tx: 168,
            block_number: 18064240,
        };

        assert_eq!(result, expected_result)
    }

    #[tokio::test]
    async fn test_builder_block_received() {
        let relay = create_relay_provider();
        let result = relay
            .builder_block_received_block_hash(
                BlockHash::from_str(
                    "0xae52fd69bb83fbe20802b8c130bed111d2f0b9620ab6d8ee369eee11e15b845e",
                )
                .unwrap(),
            )
            .await
            .expect("Failed to get builder block received")
            .expect("Builder block received not found");

        let expected_result = BuilderBlockReceived {
            slot: 7251671,
            parent_hash: BlockHash::from_str("0xe57c063ad96fb5b6fe7696dc8509f3a986ace89d06a19951f3e4404f877bb0ca").unwrap(),
            block_hash: BlockHash::from_str("0xae52fd69bb83fbe20802b8c130bed111d2f0b9620ab6d8ee369eee11e15b845e").unwrap(),
            builder_pubkey: BlsPublicKey::from_str("0x945fc51bf63613257792926c9155d7ae32db73155dc13bdfe61cd476f1fd2297b66601e8721b723cef11e4e6682e9d87").unwrap(),
            proposer_pubkey: BlsPublicKey::from_str("0xb097a69fa420d01c293fed6b2596778d0722a2b076e401c2789cabce773a17c865285ff71b5dd545c7e77bee6ef8a41b").unwrap(),
            proposer_fee_recipient: Address::from_str("0xeBec795c9c8bBD61FFc14A6662944748F299cAcf").unwrap(),
            gas_limit: 30000000,
            gas_used: 20585314,
            value: U256::from_str("513749883680431063").unwrap(),
            num_tx: 174,
            block_number: 18064240,
            timestamp: 1693844075,
            timestamp_ms: 1693844075794,
            optimistic_submission: false,
        };

        assert_eq!(result, expected_result)
    }

    #[tokio::test]
    async fn test_validator_registration() {
        let relay = create_relay_provider();
        let result = relay
            .validator_registration(BlsPublicKey::from_str("0x904e01b37a8db98695483da0025f4cc1c0ecc2b9a37ab53604c21d6788ad2a8996748ea0ce838d2926767eee0228ec69").unwrap())
            .await
            .expect("Failed to get validator registration")
        .expect("Validator registration not found");

        let expected_result = ValidatorRegistration {
            message: ValidatorRegistrationMessage {
                fee_recipient: Address::from_str("0x388c818ca8b9251b393131c08a736a67ccb19297").unwrap(),
                gas_limit: 30000000,
                timestamp: 1707146537,
                pubkey: BlsPublicKey::from_str("0x904e01b37a8db98695483da0025f4cc1c0ecc2b9a37ab53604c21d6788ad2a8996748ea0ce838d2926767eee0228ec69").unwrap(),
            },
            signature: Bytes::from_str("0xa1d5118053d39665319909d099db64f174e62ffee22c4c65f7c86f549bde1225148af3e4623dc17f2bf8a292249693bb0556ef3bd13b7ea79fe58298e3a97f93c225777376ee07e49e8db9265a32716306288f5117f24bbac445babc78a81888").unwrap(),
        };

        assert_eq!(result, expected_result)
    }

    #[tokio::test]
    async fn test_bids_without_optimistic_submission() {
        let data = "[{\"slot\":\"7397378\",\"parent_hash\":\"0x71927975871e10dfd63e773d46836a7fac9357dba02e38a5fb31532392398646\",\"block_hash\":\"0xd32c5a6b5049934cd403390465d31ed8653e3b91e7ff1ace0eb0c59cc4a15274\",\"builder_pubkey\":\"0x945fc51bf63613257792926c9155d7ae32db73155dc13bdfe61cd476f1fd2297b66601e8721b723cef11e4e6682e9d87\",\"proposer_pubkey\":\"0x98503b20c69e073669e3291a947a4c5afb91d38bd8f8c562d60ce67ad1eb68c97c04eea5cfcb39a1d398bfb86f4dc961\",\"proposer_fee_recipient\":\"0x13ad787D1F74302C6301CCf725B8688599B06da0\",\"gas_limit\":\"30000000\",\"gas_used\":\"21739227\",\"value\":\"140212076843484261\",\"num_tx\":\"194\",\"block_number\":\"18208474\",\"timestamp_ms\":\"1695592558964\",\"timestamp\":\"1695592558\"}]\n";

        let result = serde_json::from_str::<Vec<BuilderBlockReceived>>(data).unwrap();
        assert_eq!(result.len(), 1);
        assert!(!result[0].optimistic_submission);
    }

    #[tokio::test]
    async fn test_validator_slot_data() {
        let relay = create_relay_provider();

        let result = relay
            .get_current_epoch_validators()
            .await
            .expect("Failed to get validators");

        println!("len: {}", result.len());
        assert!(!result.is_empty());
        println!("result[0]: {:#?}", result[0]);
    }

    #[ignore]
    #[tokio::test]
    async fn test_send_payload_to_mevboost() {
        let srv = match FakeMevBoostRelay::new().spawn() {
            Some(srv) => srv,
            None => {
                println!("mev-boost binary not found, skipping test");
                return;
            }
        };

        let mut generator = TestDataGenerator::default();

        let relay_url = Url::from_str(&srv.endpoint()).unwrap();
        let relay = RelayClient::from_url(
            relay_url,
            None,
            None,
            None,
            false,
            Vec::new(),
            false,
            false,
            false,
        );
        let submission = SubmitBlockRequest {
            request: Arc::new(generator.create_deneb_submit_block_request()),
            adjustment_data: None,
        };
        let sub_relay = SubmitBlockRequestWithMetadata {
            submission,
            metadata: BidMetadata {
                sequence: 0,
                value: BidValueMetadata {
                    coinbase_reward: Default::default(),
                    top_competitor_bid: None,
                },
                order_ids: vec![],
                bundle_hashes: vec![],
            },
        };
        let registration = ValidatorSlotData {
            slot: 123,
            validator_index: 321,
            entry: ValidatorRegistration {
                message: ValidatorRegistrationMessage {
                    timestamp: 0,
                    gas_limit: 30_000_000,
                    fee_recipient: Address::random(),
                    pubkey: BlsPublicKey::random(),
                },
                signature: Default::default(),
            },
            regional_endpoints: Vec::new(),
        };
        relay
            .submit_block(&sub_relay, &registration, true, true, false, false)
            .await
            .expect("OPS!");
    }
}
